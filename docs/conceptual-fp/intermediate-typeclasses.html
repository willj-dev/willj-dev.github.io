<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" prefix="og: https://ogp.me/ns#">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <!-- Enable autoscaling for smol screens -->
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- OpenGraph metadata for link previews -->
    <meta property="og:title" content="Intermediate Typeclasses">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://willj.dev//conceptual-fp/intermediate-typeclasses.html">
    <meta property="og:locale" content="en_US">
    <meta property="og:site_name" content="willj.dev">

    <!-- MathJax -->
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Alegreya+Sans">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Alegreya">
    <link rel="stylesheet" href="http://fonts.cdnfonts.com/css/cascadia-code">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Icons">
    <link rel="stylesheet" type="text/css" href="../css/main.css">
    <title>Intermediate Typeclasses - willj.dev</title>
  </head>

  <body id="page-body" class="dark-mode">
    <header>
      <h1 id="header-path" class="header-element">
        <a id="header-root" href="../">willj.dev</a>
        <span class="header-sep">/</span>
        <a href="../conceptual-fp">conceptual-fp</a>
        <span class="header-sep">/</span>
        <a id="title" href="../conceptual-fp/intermediate-typeclasses.html">Intermediate Typeclasses</a></h1>
      <div class="header-fill"></div>
    </header>
    <main><div id="page-container">
  <div id="page-toc" class="contents">
    <div id="next-page">
      Previous page: <a href="./basic-concepts.html">Basic Concepts</a>
    </div>
    <ul><li><a href="#functor">Functor</a></li><li><a href="#foldable">Foldable</a></li><li><a href="#monoid">Monoid</a></li><li><a href="#applicative">Applicative</a></li><li><a href="#traversable">Traversable</a></li><li><a href="#monad">Monad</a></li></ul>
    <div id="next-page">
      Next page: <a href="./monad-field-guide.html">Monads: A Field Guide</a>
    </div>
    </div>
  <div id="page-content">
    <p>So far, the typeclasses we’ve seen have obvious analogues in non-functional languages too. This section will look at a few of the typeclasses that are particularly important to functional programming design.</p><h2 id="functor">Functor<a href="#functor" class="anchor" title="Functor">link</a></h2><p>The <code class="sourceCode pseudoml"><span class="dt">Functor</span></code> typeclass is for data types that can be treated like containers whose elements can be “mapped over.” Specifically:</p><div class="sourceCode" id="cb1"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typeclass</span> <span class="dt">Functor</span> f</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    map </span><span class="op">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div><p>You might also think about a functor as a way to apply a function <em>through</em> a data structure. Lists are a common example; indeed, many object-oriented languages give a <code class="sourceCode pseudoml">map</code> method to their array or list class.</p><div class="sourceCode" id="cb2"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> []</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    map _ []      <span class="ot">=</span> []</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    map f (x<span class="ot">::</span>xs) <span class="ot">=</span> f x <span class="ot">::</span> map f xs</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- this evaluates to [10, 4]</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>someInts <span class="ot">=</span> map stringLength [<span class="st">&quot;functional&quot;</span>, <span class="st">&quot;peep&quot;</span>]</span></code></pre></div><p><code class="sourceCode pseudoml"><span class="dt">Optional</span></code> is also a useful <code class="sourceCode pseudoml"><span class="dt">Functor</span></code>:</p><div class="sourceCode" id="cb3"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Optional</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    map _ <span class="dt">Nothing</span>  <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    map f (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre></div><h2 id="foldable">Foldable<a href="#foldable" class="anchor" title="Foldable">link</a></h2><p><code class="sourceCode pseudoml"><span class="dt">Foldable</span></code> is the typeclass of data structures that can be traversed, accumulating some result at each point:</p><div class="sourceCode" id="cb4"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typeclass</span> <span class="dt">Foldable</span> t</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    foldl </span><span class="op">:</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</span></code></pre></div><p>The <code class="sourceCode pseudoml">l</code> at the end of <code class="sourceCode pseudoml">foldl</code> indicates that this is a <em>left fold</em><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. The words “left” and “right” refer to the head and tail of a list, respectively; in general, left folds start at the “front” of a data structure (they are <em>breadth-first</em>), and right folds start at the “back” (<em>depth-first</em>). What this means is best illustrated by an example. Consider this definition of the <code class="sourceCode pseudoml">sum</code> function, which sums a list of integers:</p><div class="sourceCode" id="cb5"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Foldable</span> []</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    foldl _ acc []     <span class="ot">=</span> acc</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    foldl f acc (<span class="ot">x</span><span class="op">:</span>xs) <span class="ot">=</span> foldl f (f acc x) xs</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="ot">sum </span><span class="op">:</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>sum <span class="ot">=</span> foldl (<span class="op">+</span>) <span class="dv">0</span></span></code></pre></div><p>Now let’s consider what happens when this function is evaluated.</p><pre><code>sum [1, 2, 4, 8]
foldl (+) 0 [1, 2, 4, 8]
foldl (+) (0 + 1) [2, 4, 8]
foldl (+) ((0 + 1) + 2) [4, 8]
foldl (+) (((0 + 1) + 2) + 4) [8]
foldl (+) ((((0 + 1) + 2) + 4) + 8) []
((((0 + 1) + 2) + 4) + 8)</code></pre><p>As you can see, the first thing to be evaluated is <span class="math inline">\(0 + 1\)</span>, and we proceed down the list, evaluating the “left-most” operations first. This implies the existence of a <em>right fold</em><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>:</p><div class="sourceCode" id="cb7"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foldrList </span><span class="op">:</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>foldrList _ b [] <span class="ot">=</span> b</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>foldrList f b (x <span class="ot">::</span> xs) <span class="ot">=</span> f x (foldr f b xs)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="ot">sumr </span><span class="op">:</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>sumr <span class="ot">=</span> foldr (<span class="op">+</span>) <span class="dv">0</span></span></code></pre></div><p>When this is evaluated, we get</p><pre><code>sumr [1, 2, 4, 8]
foldr (+) 0 [1, 2, 4, 8]
(1 + (foldr (+) 0 [2, 4, 8]))
(1 + (2 + (foldr (+) 0 [4, 8])))
(1 + (2 + (4 + (foldr (+) 0 [8]))))
(1 + (2 + (4 + (8 + (foldr (+) 0 [])))))
(1 + (2 + (4 + (8 + 0))))</code></pre><p>Unsurprisingly, now we’re starting on the right! This ends up evaluating to the same result, but that is only the case for <em>associative</em> operations. You may recall from math class that this has to do with how we group a series of operations; if we just write <span class="math inline">\(0 + 1 + 2 + 4 + 8\)</span> there are five different <span class="math inline">\(+\)</span>s that we could choose to evaluate first. Of course, with addition, it doesn’t matter; any way we group the operations comes out to the same result. We call functions with this property associative. On the other hand, subtraction is definitely not associative:</p><pre><code>((((0 - 1) - 2) - 4) - 8) = -15
(1 - (2 - (4 - (8 - 0)))) = -5</code></pre><p>In this case, <code class="sourceCode pseudoml">foldl</code> and <code class="sourceCode pseudoml">foldr</code> give different results! This isn’t actually that big of a deal though–if you know which side you’re starting from, you can always define your folding function appropriately (and perhaps reverse your list) in order to get the result you want. It turns out, though, that sometimes it does matter which fold you choose!</p><p>The examples above with <code class="sourceCode pseudoml">(<span class="op">+</span>)</code> are <em>reductions</em>: they collapse the list as they traverse it. Both reductions happen in linear time (since they traverse the input list exactly once), but <code class="sourceCode pseudoml">foldl</code> happens in constant space, while <code class="sourceCode pseudoml">foldr</code> uses linear space! For very long lists, this can easily overflow the stack. The reason is that when folding from the left, we’re keeping a “running total” of the folded value; each rescursive call need not generate its own stack frame, so the fold only needs as much memory as is required to store the result value. On the other hand, folding from the right means that we must traverse the entire list before we can start evaluating stuff, and each time we recurse further into the list, we have to hold on to the current value while we wait for the evaluation to work its way back up the stack!</p><p>However, not all folds are reductions, and interestingly, the situation is reversed for non-reductive folds. Consider the two functions below, which implement <code class="sourceCode pseudoml">map</code> over a list, one with a left fold and the other with a right fold. You should be able to convince yourself that they both produce the same result as we saw for the <code class="sourceCode pseudoml"><span class="dt">Functor</span></code> instance above:</p><div class="sourceCode" id="cb10"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapl </span><span class="op">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>mapl f <span class="ot">=</span> foldl mapAndAppend [] <span class="kw">where</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    mapAndAppend ys x <span class="ot">=</span> ys <span class="op">++</span> [f x]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="ot">mapr </span><span class="op">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>mapr f <span class="ot">=</span> foldr mapAndPrepend [] <span class="kw">where</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    mapAndPrepend x ys <span class="ot">=</span> f x <span class="ot">::</span> ys</span></code></pre></div><p>Note that when we’re folding from the left, we put each successive result at the <em>end</em> of the new list. Likewise, when we’re folding from the right, we start at the end of the list, so we append each result to the head of the new list. Evaluating these as we did before, we get</p><div class="sourceCode" id="cb11"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>mapl stringLength [<span class="st">&quot;Mrs&quot;</span>, <span class="st">&quot;Birdy&quot;</span>, <span class="st">&quot;says&quot;</span>, <span class="st">&quot;peep&quot;</span>]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- (((([] ++ [3]) ++ [5]) ++ [4]) ++ [4])</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>mapr stringLength [<span class="st">&quot;Mrs&quot;</span>, <span class="st">&quot;Birdy&quot;</span>, <span class="st">&quot;says&quot;</span>, <span class="st">&quot;peep&quot;</span>]</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- (3 :: (5 :: (4 :: (4 :: []))))</span></span></code></pre></div><p>The problem here is that concatenation using <code class="sourceCode pseudoml"><span class="op">++</span></code> runs in time proportional to the length of the left-hand list, and each time we do a concatenation, the left-hand list gets bigger; suddenly our left fold is in <em>quadratic time</em>! We would therefore rather choose a right fold for this job, because it allows us to use the constant-time list constructor <code class="sourceCode pseudoml"><span class="ot">::</span></code> rather than linear-time concatenation.</p><p>Now, depending on your language’s evaluation rules, how it implements lists, and particuarly how smart its optimizer is, your mileage may vary. The moral of this story is that you should choose your fold so that reductions are <em>strict and tail-recursive</em>, and non-reductive folds build the output structure efficiently, using only constant-time operations (if possible).</p><h2 id="monoid">Monoid<a href="#monoid" class="anchor" title="Monoid">link</a></h2><p>First, a warning: monoids are to monads as Java is to JavaScript, so apologies in advance for the similar words. Blame mathematicians again.</p><p>Here’s the definition of <code class="sourceCode pseudoml"><span class="dt">Monoid</span></code>:</p><div class="sourceCode" id="cb12"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typeclass</span> <span class="dt">Monoid</span> a</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    empty </span><span class="op">:</span> a</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&lt;&gt;) </span><span class="op">:</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span></code></pre></div><p>This can be read a couple of different ways. Usually the one folks see first treats <code class="sourceCode pseudoml"><span class="op">&lt;&gt;</span></code> as an operator for glomming two instances of the monoid together, with <code class="sourceCode pseudoml">empty</code> as the “neutral” element; for example, with integers:</p><div class="sourceCode" id="cb13"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Int</span> <span class="kw">as</span> <span class="dt">Sum</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    empty <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;&gt;</span>)  <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="ot">sum </span><span class="op">:</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>sum xs <span class="ot">=</span> foldl (<span class="op">&lt;&gt;</span> <span class="kw">using</span> <span class="dt">Prod</span>)</span></code></pre></div><p>Notice that I have named the instance; this can sometimes be useful, because there may be multiple ways for a given data type to implement a typeclass. Such as:</p><div class="sourceCode" id="cb14"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Int</span> <span class="kw">as</span> <span class="dt">Product</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    empty <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;&gt;</span>)  <span class="ot">=</span> (<span class="op">*</span>)</span></code></pre></div><p>Each of these specifies a particular way that integers can be stuck together. With these examples handy, we can write down the <em>monoid laws</em>:</p><dl><dt>Associativity</dt><dd><p><code class="sourceCode pseudoml">(x <span class="op">&lt;&gt;</span> y) <span class="op">&lt;&gt;</span> z <span class="op">==</span> x <span class="op">&lt;&gt;</span> (y <span class="op">&lt;&gt;</span> z)</code></p></dd><dt>Identity</dt><dd><p><code class="sourceCode pseudoml">x <span class="op">&lt;&gt;</span> empty <span class="op">==</span> empty <span class="op">&lt;&gt;</span> x <span class="op">==</span> x</code></p></dd></dl><p>The requirement that <code class="sourceCode pseudoml"><span class="op">&lt;&gt;</span></code> be associative means that there aren’t monoid instances for division or subtraction. (By the way, division has another problem too; <code class="sourceCode pseudoml"><span class="op">&lt;&gt;</span></code> should always be defined for all values, but division by zero isn’t defined!)</p><p>The other way to interpret a monoid is as a way to choose between two values with <code class="sourceCode pseudoml"><span class="op">&lt;&gt;</span></code>, with <code class="sourceCode pseudoml">empty</code> providing a default choice.</p><div class="sourceCode" id="cb15"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Maybe</span> a) <span class="kw">as</span> <span class="dt">First</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    empty <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> x <span class="op">&lt;&gt;</span> <span class="dt">Just</span> y <span class="ot">=</span> <span class="dt">Just</span> x</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    x <span class="op">&lt;&gt;</span> <span class="dt">Nothing</span>     <span class="ot">=</span> x</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="op">&lt;&gt;</span> x     <span class="ot">=</span> x</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Maybe</span> a) <span class="kw">as</span> <span class="dt">Last</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    empty <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> x <span class="op">&lt;&gt;</span> <span class="dt">Just</span> y <span class="ot">=</span> <span class="dt">Just</span> y</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    x <span class="op">&lt;&gt;</span> <span class="dt">Nothing</span>     <span class="ot">=</span> x</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="op">&lt;&gt;</span> x     <span class="ot">=</span> x</span></code></pre></div><p>Here, the <code class="sourceCode pseudoml"><span class="dt">First</span></code> instance always chooses the first non-<code class="sourceCode pseudoml"><span class="dt">Nothing</span></code> value it was given; likewise, <code class="sourceCode pseudoml"><span class="dt">Last</span></code> always chooses the last.</p><p>As a final example, <code class="sourceCode pseudoml"><span class="dt">Bool</span></code> also admits two possible monoids:</p><div class="sourceCode" id="cb16"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Bool</span> <span class="kw">as</span> <span class="dt">All</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    empty <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;&gt;</span>)  <span class="ot">=</span> (<span class="op">&amp;&amp;</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Maybe</span> a) <span class="kw">as</span> <span class="dt">Any</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    empty <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;&gt;</span>)  <span class="ot">=</span> (<span class="op">||</span>)</span></code></pre></div><h2 id="applicative">Applicative<a href="#applicative" class="anchor" title="Applicative">link</a></h2><p>The extravagantly-named <em>applicative functor</em> is, of course, simply a functor that is applicative!</p><p>That sounds deeply, almost offensively unhelpful, but interestingly it’s one of the more meaningful names for important concepts (looking at you, ‘Monad’). To illustrate what it means, let’s consider a puzzle. A program has asked the user for two integers, <code class="sourceCode pseudoml">x</code> and <code class="sourceCode pseudoml">y</code>, but since getting these integers involves communing with the outside world of side effects, they are both of type <code class="sourceCode pseudoml"><span class="dt">IO</span> <span class="dt">Int</span></code>. Your goal is to add them together. How can we do this?</p><p>Unlike most data types, <code class="sourceCode pseudoml"><span class="dt">IO</span></code> values cannot be “unwrapped”, because that would defeat the purpose of keeping side effects contained. <code class="sourceCode pseudoml"><span class="dt">IO</span></code> is a functor, so we can do things like</p><div class="sourceCode" id="cb17"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">x </span><span class="op">:</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> askUserForInt</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="ot">y </span><span class="op">:</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>y <span class="ot">=</span> askUserForInt</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="ot">z </span><span class="op">:</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>z <span class="ot">=</span> map (<span class="op">*</span><span class="dv">2</span>) x <span class="co">-- double it!</span></span></code></pre></div><p>but before you ask, <code class="sourceCode pseudoml">x <span class="op">+</span> y</code> doesn’t work because <code class="sourceCode pseudoml"><span class="dt">IO</span> <span class="dt">Int</span></code> is not a number! It’s more like a <em>promise</em> of a number, and in fact thinking about <code class="sourceCode pseudoml"><span class="dt">IO</span></code> like an ES <code class="sourceCode pseudoml"><span class="dt">Promise</span></code> or a Java <code class="sourceCode pseudoml"><span class="dt">CompletableFuture</span></code> is not a terrible approximation.</p><p>Okay fine, it’s a trick question, and presumably you have already figured out that the answer has to do with whatever an applicative is. Plain functors simply don’t provide enough power to support this sort of operation. Happily, <code class="sourceCode pseudoml"><span class="dt">IO</span></code> is an <code class="sourceCode pseudoml"><span class="dt">Applicative</span></code>, which gives us access to this gadget:</p><div class="sourceCode" id="cb18"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftA2 </span><span class="op">:</span> (<span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- definition will come in a moment!</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="ot">addTwoIOs </span><span class="op">:</span> <span class="dt">IO</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>addTwoIOs <span class="ot">=</span> liftA2 (<span class="op">+</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>addXAndY <span class="ot">=</span> addTwoIOs x y <span class="co">-- ta da!</span></span></code></pre></div><p>The function <code class="sourceCode pseudoml">liftA2</code> takes a pure function of two arguments, and turns it into a function over an Applicative. The term <em>lift</em> is one that will occur a lot; it’s usually given to a function that takes a “plain” function and transforms it into a “special” one—e.g. *lifting* the humble <code class="sourceCode pseudoml">(<span class="op">+</span>)</code> into the exciting world of <code class="sourceCode pseudoml"><span class="dt">IO</span></code>. “<code class="sourceCode pseudoml">liftA</code>” denotes a lift into Applicatives, and “<code class="sourceCode pseudoml">liftA2</code>” indicates that it operates on functions of two arguments; once you get over that hurdle, it’s easy enough to construct <code class="sourceCode pseudoml">liftA</code><span class="math inline">\(n\)</span> but usually that’s excessive. In fact, you’ve already seen <code class="sourceCode pseudoml">liftA1</code>: it’s just functor <code class="sourceCode pseudoml">map</code>!</p><div class="sourceCode" id="cb19"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftA1 </span><span class="op">:</span> (<span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- where have I seen this type signature before?</span></span></code></pre></div><p>Hopefully that is enough to start shedding light on the name <em>applicative functor</em>. Let’s look at how it’s actually defined.</p><div class="sourceCode" id="cb20"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typeclass</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    pure  </span><span class="op">:</span> a <span class="ot">-&gt;</span> f a</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&lt;*&gt;) </span><span class="op">:</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div><p>The <code class="sourceCode pseudoml">pure</code> function lifts a plain value into an applicative. The name is intended to suggest that we’re getting “just” that value: no spooky side effects, no accidental emails to scandalize grandma, it’s a pure value. For instance, if we didn’t want to bother asking the user for numbers (they would probably screw it up anyway), we could just say</p><div class="sourceCode" id="cb21"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">myX </span><span class="op">:</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>myX <span class="ot">=</span> pure <span class="dv">2</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="ot">myY </span><span class="op">:</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>myY <span class="ot">=</span> pure <span class="dv">3</span></span></code></pre></div><p>The other thing, <code class="sourceCode pseudoml">(<span class="op">&lt;*&gt;</span>)</code>, is pronounced “apply”, and it takes a lifted single-argument function and applies it to a lifted value. These two things together allow us to define <code class="sourceCode pseudoml">liftA2</code>:</p><div class="sourceCode" id="cb22"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftA2 </span><span class="op">:</span> (<span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>liftA2 f x y <span class="ot">=</span> pure f <span class="op">&lt;*&gt;</span> x <span class="op">&lt;*&gt;</span> y</span></code></pre></div><p>Which is to say, we lift <code class="sourceCode pseudoml">f</code> up into the applicative, (partially!) apply it to <code class="sourceCode pseudoml">x</code>, and then finally apply that to <code class="sourceCode pseudoml">y</code>. In fact, we could have started with <code class="sourceCode pseudoml">liftA2</code> instead:</p><div class="sourceCode" id="cb23"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;*&gt;) </span><span class="op">:</span> (<span class="dt">Applicative</span> f) <span class="ot">-&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">&lt;*&gt;</span> x <span class="ot">=</span> liftA2 id f x</span></code></pre></div><h2 id="traversable">Traversable<a href="#traversable" class="anchor" title="Traversable">link</a></h2><h2 id="monad">Monad<a href="#monad" class="anchor" title="Monad">link</a></h2><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>This is also called a <em>left-associative</em> fold, when there are mathematicians around.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>See <a href="./appendix-foldr.html">Right Folds from the Left</a> for a generic right-fold, if all we have to start with is a left-fold<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>
  </div>
</div>
</main>
    <footer>
      <span id="site-source" class="footer-element">
        <a href="https://github.com/willj-dev/willj-dev.github.io/">Site Source</a>
      </span>
      <span class="footer-divider">|</span>
      <span id="site-source" class="footer-element">
        <a href="https://github.com/willj-dev/willj-dev.github.io/tree/main/content/pages/conceptual-fp/intermediate-typeclasses.rst">Page Source</a>
      </span>
      <span class="footer-divider">|</span>
      <div id="dark-mode" class="footer-element light-mode-only">Dark Mode</div>
      <div id="light-mode" class="footer-element dark-mode-only">Light Mode</div>
      <div class="footer-fill"></div>
      <span id="built-with" class="footer-element">
        Built with <a href="https://jaspervdj.be/hakyll">Hakyll</a>
      </span>
      <span class="footer-divider">|</span>
      <span id="hosted-by" class="footer-element">
        Hosted by <a href="https://pages.github.com">GitHub Pages</a>
      </span>
      <span class="footer-divider">|</span>
      <span id="colors-credit" class="footer-element">
        <a href="https://github.com/chriskempson/base16">Base16</a> color scheme:
        <a href="https://github.com/chriskempson/base16-tomorrow-scheme">
          Tomorrow<span class="dark-mode-only"> Night</span>
        </a>
      </span>
    </footer>
  </body>
  <script src="../js/colorMode.js"></script>
</html>

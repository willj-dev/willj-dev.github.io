<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" prefix="og: https://ogp.me/ns#">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <!-- Enable autoscaling for smol screens -->
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- OpenGraph metadata for link previews -->
    <meta property="og:title" content="Monads: A Field Guide">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://willj.dev//conceptual-fp/monad-field-guide.html">
    <meta property="og:locale" content="en_US">
    <meta property="og:site_name" content="willj.dev">

    <!-- MathJax -->
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Alegreya+Sans">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Alegreya">
    <link rel="stylesheet" href="https://fonts.cdnfonts.com/css/cascadia-code">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Icons">
    <link rel="stylesheet" type="text/css" href="../css/main.css">
    <title>Monads: A Field Guide - willj.dev</title>
  </head>

  <body id="page-body" class="dark-mode">
    <header>
      <h1 id="header-path" class="header-element">
        <a id="header-root" href="../">willj.dev</a>
        <span class="header-sep">/</span>
        <a href="../conceptual-fp">conceptual-fp</a>
        <span class="header-sep">/</span>
        <a id="title" href="../conceptual-fp/monad-field-guide.html">Monads: A Field Guide</a></h1>
      <div class="header-fill"></div>
    </header>
    <main><div id="page-container">
  <div id="page-toc" class="contents">
    <div id="next-page">
      Previous page: <a href="./intermediate-typeclasses.html">Intermediate Typeclasses</a>
    </div>
    <ul>
<li><a href="#io" id="toc-io">IO</a></li>
<li><a href="#optional" id="toc-optional">Optional</a></li>
<li><a href="#list" id="toc-list">List</a></li>
<li><a href="#either" id="toc-either">Either</a></li>
<li><a href="#reader" id="toc-reader">Reader</a></li>
<li><a href="#writer" id="toc-writer">Writer</a></li>
<li><a href="#state" id="toc-state">State</a></li>
</ul>
    <div id="next-page">
      Next page: <a href="./recursion-schemes.html">Recursion Schemes</a>
    </div>
    </div>
  <div id="page-content">
    <p>Although we have already discussed what a monad is in general, the actual semantics—what it means for a given type to be a monad—depends on the type itself. Here we’ll go over a few of the more common examples of monadic types, how their <code class="sourceCode pseudoml"><span class="dt">Monad</span></code> instances are defined, and how they are used.</p>
<p>We are focusing on monads here, but for reference we will define the entire <code class="sourceCode pseudoml"><span class="dt">Monad</span></code> type ancestry (i.e. <code class="sourceCode pseudoml"><span class="dt">Functor</span></code>, <code class="sourceCode pseudoml"><span class="dt">Applicative</span></code>, and <code class="sourceCode pseudoml"><span class="dt">Monad</span></code>) together.</p>
<h2 id="io">IO<a href="#io" class="anchor" title="IO">link</a></h2>
<p>The <code class="sourceCode pseudoml"><span class="dt">IO</span></code> monad is perhaps the most (and least) boring of all; it really just wraps a value that can be chained together with other <code class="sourceCode pseudoml"><span class="dt">IO</span></code> operations with no actual semantics beyond interacting with the outside world of side effects. By definition its implementation is language-specific, so we will skip right on past to its more language-agnostic relatives.</p>
<h2 id="optional">Optional<a href="#optional" class="anchor" title="Optional">link</a></h2>
<p>Good old <code class="sourceCode pseudoml"><span class="dt">Optional</span></code> is a <code class="sourceCode pseudoml"><span class="dt">Monad</span></code> used for chaining computations that may or may not have a result; after the first one that doesn’t, none of the following computations run.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Optional</span> a <span class="ot">=</span> <span class="dt">Just</span> a <span class="op">|</span> <span class="dt">Nothing</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Optional</span> <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    map f (<span class="dt">Just</span> a)  <span class="ot">=</span> <span class="dt">Just</span> (f a)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    map f (<span class="dt">Nothing</span>) <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Optional</span> <span class="kw">where</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    pure <span class="ot">=</span> <span class="dt">Just</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Just</span> f) <span class="op">&lt;*&gt;</span> (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span>  <span class="op">&lt;*&gt;</span> _        <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    _        <span class="op">&lt;*&gt;</span> <span class="dt">Nothing</span>  <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Optional</span> <span class="kw">where</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> a  <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> f a</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="op">&gt;&gt;=</span> _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>Here’s what it looks like if you need to chain a bunch of <code class="sourceCode pseudoml"><span class="dt">Optional</span></code> results together without monadic operations:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foo </span><span class="op">:</span> <span class="dt">Optional</span> a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">bar </span><span class="op">:</span> a <span class="ot">-&gt;</span> <span class="dt">Optional</span> b</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">baz </span><span class="op">:</span> b <span class="ot">-&gt;</span> <span class="dt">Optional</span> c</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>resultPlain <span class="ot">=</span> case foo of</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> a  <span class="ot">-&gt;</span> case bar a of</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> b  <span class="ot">-&gt;</span> baz b</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">None</span>    <span class="ot">-&gt;</span> <span class="dt">None</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">None</span>    <span class="ot">-&gt;</span> <span class="dt">None</span></span></code></pre></div>
<p>The repeated case matching can be replaced by a sequence of monad binds:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>resultMonadic <span class="ot">=</span> foo <span class="op">&gt;&gt;=</span> bar <span class="op">&gt;&gt;=</span> baz</span></code></pre></div>
<p>That looks much neater! If you check the definition of the <code class="sourceCode pseudoml"><span class="dt">Optional</span></code> monad, you can see how the null-checking structure is built in to the definition of <code class="sourceCode pseudoml"><span class="op">&gt;&gt;=</span></code>, which is how we are able to skip so much repetition with monadic code.</p>
<h2 id="list">List<a href="#list" class="anchor" title="List">link</a></h2>
<p>The <code class="sourceCode pseudoml"><span class="dt">List</span></code> monad has a different meaning entirely, which is somewhat suprising since there is a tendency to believe that two instances of the same class should have similar semantics. That is true, in a sense, but the similarities are somewhat hard to spot. Here is how it is defined:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> [] <span class="op">|</span> a <span class="ot">::</span> <span class="dt">List</span> a      <span class="co">-- empty list, or head + tail</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">List</span> <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    map f []        <span class="ot">=</span> []</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    map f (x <span class="ot">::</span> xs) <span class="ot">=</span> f x <span class="ot">::</span> (map f xs)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">List</span> <span class="kw">where</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    pure x <span class="ot">=</span> x <span class="ot">::</span> []                                <span class="co">-- a list with one element; the tail is empty</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    []        <span class="op">&lt;*&gt;</span> _         <span class="ot">=</span> []</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    _         <span class="op">&lt;*&gt;</span> []        <span class="ot">=</span> []</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    (f <span class="ot">::</span> fs) <span class="op">&lt;*&gt;</span> xs <span class="ot">=</span> map f xs <span class="op">++</span> (fs <span class="op">&lt;*&gt;</span> xs)      <span class="co">-- map each function over each argument and concat them all</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">List</span> <span class="kw">where</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    []        <span class="op">&gt;&gt;=</span> _ <span class="ot">=</span> []</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    (x <span class="ot">::</span> xs) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> f x <span class="op">++</span> (f <span class="op">&gt;&gt;=</span> xs)             <span class="co">-- concatenate results for each argument</span></span></code></pre></div>
<p>To make sense of this, let’s start with <code class="sourceCode pseudoml"><span class="op">&lt;*&gt;</span></code>. What is its type signature for lists?</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;*&gt;) </span><span class="op">:</span> [a <span class="ot">-&gt;</span> b] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span></code></pre></div>
<p>In other words, it takes a list of functions, and a list of arguments, and returns a list of results. This is why we have to do a lot of list concatenation: the obvious answer to what that type signature means is “apply each function to each possible argument.”</p>
<p>Now for bind:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) </span><span class="op">:</span> [a] <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [b]</span></code></pre></div>
<p>This takes a list of arguments, and a function from <em>one</em> argument to a list of results, and returns a list of results. Thus, the meaning of the list monad is to chain a bunch of functions that produce multiple results into one operation that produces <em>a lot</em> of results!</p>
<p>It may seem surprising that the same typeclass that gave us free null checks with <code class="sourceCode pseudoml"><span class="dt">Optional</span></code> gives us this weird concatenation behavior with <code class="sourceCode pseudoml"><span class="dt">List</span></code>s. But the main point is that in both cases, we are chaining function results together within a particular “container” type. How we interpret that chaining behavior just depends on what the type of container we’re using.</p>
<p>Using the <code class="sourceCode pseudoml"><span class="dt">List</span></code> monad is equivalent to repeated calls to <code class="sourceCode pseudoml">map</code> and <code class="sourceCode pseudoml">flatten</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foo </span><span class="op">:</span> [a]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">bar </span><span class="op">:</span> a <span class="ot">-&gt;</span> [b]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ot">baz </span><span class="op">:</span> b <span class="ot">-&gt;</span> [c]</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="ot">flatten </span><span class="op">:</span> [[x]] <span class="ot">-&gt;</span> [x]</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>flatten []          <span class="ot">=</span> []</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>flatten (xs <span class="ot">::</span> xss) <span class="ot">=</span> xs <span class="op">++</span> flatten xss</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>resultPlain <span class="ot">=</span> flatten (map baz (flatten (map bar foo)))</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>resultMonadic <span class="ot">=</span> foo <span class="op">&gt;&gt;=</span> bar <span class="op">&gt;&gt;=</span> baz</span></code></pre></div>
<h2 id="either">Either<a href="#either" class="anchor" title="Either">link</a></h2>
<p>The <code class="sourceCode pseudoml"><span class="dt">Either</span></code> type is another odd one. It takes two type parameters:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Either</span> a b <span class="ot">=</span> <span class="dt">Left</span> a <span class="op">|</span> <span class="dt">Right</span> b</span></code></pre></div>
<p>From this it should be clear that it simply represents a value that can be one of two possible types. The weirdness comes when we realize that things like <code class="sourceCode pseudoml"><span class="dt">Functor</span></code> can only map over one type parameter <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Either</span> a) <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    map f (<span class="dt">Left</span> e)  <span class="ot">=</span> <span class="dt">Left</span> e</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    map f (<span class="dt">Right</span> a) <span class="ot">=</span> <span class="dt">Right</span> (f a)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Either</span> a) <span class="kw">where</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    pure x <span class="ot">=</span> <span class="dt">Right</span> x</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Right</span> f) <span class="op">&lt;*&gt;</span> (<span class="dt">Right</span> x) <span class="ot">=</span> <span class="dt">Right</span> (f x)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Left</span> e)  <span class="op">&lt;*&gt;</span> _         <span class="ot">=</span> <span class="dt">Left</span> e</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    _         <span class="op">&lt;*&gt;</span> (<span class="dt">Left</span> e)  <span class="ot">=</span> <span class="dt">Left</span> e</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Either</span> a) <span class="kw">where</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Right</span> x) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> f x</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Left</span> e)  <span class="op">&gt;&gt;=</span> _ <span class="ot">=</span> <span class="dt">Left</span> e</span></code></pre></div>
<p>If you work out the type signature for <code class="sourceCode pseudoml">map</code> over <code class="sourceCode pseudoml"><span class="dt">Either</span> a b</code>, you’ll find that it looks like</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">map </span><span class="op">:</span> <span class="dt">Either</span> a b <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Either</span> b c</span></code></pre></div>
<p>This is why we can’t do anything with a <code class="sourceCode pseudoml"><span class="dt">Left</span></code> value other than leave it alone. All of this is backstory for the main point, which is that <code class="sourceCode pseudoml"><span class="dt">Either</span></code> is generally used for operations that can “error out”, where a <code class="sourceCode pseudoml"><span class="dt">Left</span></code> value wraps an error and a <code class="sourceCode pseudoml"><span class="dt">Right</span></code> value wraps a successful result.</p>
<p>The non-monadic version is rather like <code class="sourceCode pseudoml"><span class="dt">Optional</span></code>, where we have to do a bunch of nested pattern matching to “short-circuit” the computation when a <code class="sourceCode pseudoml"><span class="dt">Left</span></code> value appears.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foo </span><span class="op">:</span> <span class="dt">Either</span> err a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">bar </span><span class="op">:</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> err b</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ot">baz </span><span class="op">:</span> b <span class="ot">-&gt;</span> <span class="dt">Either</span> err c</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>resultPlain <span class="ot">=</span> case foo of</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> a <span class="ot">-&gt;</span> case bar a of</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Right</span> b <span class="ot">-&gt;</span> baz b</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span> e  <span class="ot">-&gt;</span> <span class="dt">Left</span> e</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span> e  <span class="ot">-&gt;</span> <span class="dt">Left</span> e</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>resultMonadic <span class="ot">=</span> foo <span class="op">&gt;&gt;=</span> bar <span class="op">&gt;&gt;=</span> baz</span></code></pre></div>
<h2 id="reader">Reader<a href="#reader" class="anchor" title="Reader">link</a></h2>
<p><code class="sourceCode pseudoml"><span class="dt">Reader</span> e a</code> is the type of computations that all need access to some kind of shared configuration or other environment <code class="sourceCode pseudoml">e</code> and produce a result of type <code class="sourceCode pseudoml">a</code>. This is just another way of saying it’s a synonym for functions from <code class="sourceCode pseudoml">e</code> to <code class="sourceCode pseudoml">a</code>:<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Reader</span> e a <span class="ot">=</span> (e <span class="ot">-&gt;</span> a)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Reader</span> e) <span class="kw">where</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    map <span class="ot">=</span> (<span class="op">.</span>)                   <span class="co">-- function composition!</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Reader</span> e) <span class="kw">where</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    pure <span class="ot">=</span> const                <span class="co">-- const x makes a &quot;constant function&quot; that always returns x</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    f <span class="op">&lt;*&gt;</span> g <span class="ot">=</span> \e <span class="ot">-&gt;</span> f e (g e)   <span class="co">-- thread the environment to both Readers</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Reader</span> e) <span class="kw">where</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    f <span class="op">&gt;&gt;=</span> g <span class="ot">=</span> \e <span class="ot">-&gt;</span> g (f e) e   <span class="co">-- thread the environment through the input and the output</span></span></code></pre></div>
<p>Those definitions are really weird, and to be honest I had to work them out via their type signatures. This is an excellent exercise in programming with types, so let’s go over how that works!</p>
<p>First, for <code class="sourceCode pseudoml">map</code>, we should have</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">map </span><span class="op">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Reader</span> e a <span class="ot">-&gt;</span> <span class="dt">Reader</span> e b</span></code></pre></div>
<p>which is to say,</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">map </span><span class="op">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> b)</span></code></pre></div>
<p>This is how we know that this is the same as function composition - it’s the same type signature, and that’s really the only way to achieve this type in general!</p>
<p>Now for <code class="sourceCode pseudoml">pure</code>, we have</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pure </span><span class="op">:</span> a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> a)</span></code></pre></div>
<p>This says “give me an <code class="sourceCode pseudoml">a</code>, and I’ll give you a function that returns a <code class="sourceCode pseudoml">a</code> for any input <code class="sourceCode pseudoml">e</code>.” Once again, there’s only one option, which is the <code class="sourceCode pseudoml">const</code> function:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">const </span><span class="op">:</span> a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> a)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>const x <span class="ot">=</span> \_ <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>Now for a more interesting one, we have applicative apply:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;*&gt;) </span><span class="op">:</span> <span class="dt">Reader</span> e (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Reader</span> e a <span class="ot">-&gt;</span> <span class="dt">Reader</span> e b</span></code></pre></div>
<p>which resolves to</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;*&gt;) </span><span class="op">:</span> (e <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> b)</span></code></pre></div>
<p>We know that the end result needs to be a function of <code class="sourceCode pseudoml">e</code>, so we’ll start there:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">&lt;*&gt;</span> g <span class="ot">=</span> \e <span class="ot">-&gt;</span> <span class="op">???</span></span></code></pre></div>
<p>We can plug that <code class="sourceCode pseudoml">e</code> into <code class="sourceCode pseudoml">g</code> to get an <code class="sourceCode pseudoml">a</code>, and then we can get the <code class="sourceCode pseudoml">b</code> we are looking for by plugging both of those into <code class="sourceCode pseudoml">f</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">&lt;*&gt;</span> g <span class="ot">=</span> \e <span class="ot">-&gt;</span> f e (g e)</span></code></pre></div>
<p>Hopefully the meaning of this is starting to become clear, in the context of computations that refer to a common environment <code class="sourceCode pseudoml">e</code>. Here <code class="sourceCode pseudoml">f</code> is a function that takes the environment <em>and another argument</em>, and <code class="sourceCode pseudoml">g</code> is a function that takes the environment and produces a value that can be plugged into <code class="sourceCode pseudoml">f</code>. All we had to do was figure out how to socket all these things into the right places to achieve the type we wanted.</p>
<p>Finally, monad bind:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) </span><span class="op">:</span> <span class="dt">Reader</span> e a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Reader</span> e b) <span class="ot">-&gt;</span> <span class="dt">Reader</span> e b</span></code></pre></div>
<p>i.e.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) </span><span class="op">:</span> (e <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> b)</span></code></pre></div>
<p>Once again, we start with a function from <code class="sourceCode pseudoml">e</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;&gt;=</span> g <span class="ot">=</span> \e <span class="ot">-&gt;</span> <span class="op">???</span></span></code></pre></div>
<p>Now, however, we’re a little backwards from what we used for <code class="sourceCode pseudoml">(<span class="op">&lt;*&gt;</span>)</code>. We plug the <code class="sourceCode pseudoml">e</code> into <code class="sourceCode pseudoml">f</code> to get an <code class="sourceCode pseudoml">a</code>, and then we can plug <em>that</em> into <code class="sourceCode pseudoml">g</code> along with <code class="sourceCode pseudoml">e</code> (again) to produce the <code class="sourceCode pseudoml">b</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;&gt;=</span> g <span class="ot">=</span> \e <span class="ot">-&gt;</span> g (f e) e</span></code></pre></div>
<p>The point of the <code class="sourceCode pseudoml"><span class="dt">Reader</span></code> monad is to save on constantly passing the environment down into sub-steps of a larger computation, similarly to how it saves us from having to constantly pattern-match on <code class="sourceCode pseudoml"><span class="dt">Optional</span></code> cases:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foo </span><span class="op">:</span> <span class="dt">Reader</span> e a</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="ot">bar </span><span class="op">:</span> a <span class="ot">-&gt;</span> <span class="dt">Reader</span> e b</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="ot">baz </span><span class="op">:</span> b <span class="ot">-&gt;</span> <span class="dt">Reader</span> e c</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>resultPlain <span class="ot">=</span> baz (bar (foo e) e) e</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>resultMonadic <span class="ot">=</span> (foo <span class="op">&gt;&gt;=</span> bar <span class="op">&gt;&gt;=</span> baz) e</span></code></pre></div>
<p>In the monadic version, we only needed to explicitly pass the <code class="sourceCode pseudoml">e</code> parameter once! Of course, in this simple example it hardly made a difference, but for more complex systems, this can be a huge saving in readability.</p>
<h2 id="writer">Writer<a href="#writer" class="anchor" title="Writer">link</a></h2>
<p><code class="sourceCode pseudoml"><span class="dt">Writer</span> o a</code> is used for operations that successively append to a stream of output data <code class="sourceCode pseudoml">o</code>, such as a record of which steps were taken or an incremental parser, in addition to the result type <code class="sourceCode pseudoml">a</code> of each step. It can easily be implemented as a tuple:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Writer</span> o a <span class="ot">=</span> (o, a)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Writer</span> o) <span class="kw">where</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    map f (o, a) <span class="ot">=</span> (o, f a)     <span class="co">-- map the value, leave the accumulated value alone</span></span></code></pre></div>
<p>The <code class="sourceCode pseudoml"><span class="dt">Functor</span></code> instance is easy enough, but we need something extra for <code class="sourceCode pseudoml"><span class="dt">Applicative</span></code> and <code class="sourceCode pseudoml"><span class="dt">Monad</span></code>; we’re missing a way to start the accumulated output with <code class="sourceCode pseudoml">pure</code>, and add them together across each step in our computation with <code class="sourceCode pseudoml">(<span class="op">&lt;*&gt;</span>)</code>. Luckily, we already have a way to define those two operations: the output just needs to be a <code class="sourceCode pseudoml"><span class="dt">Monoid</span></code>!</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> o) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Writer</span> o) <span class="kw">where</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    pure x <span class="ot">=</span> (empty, x)         <span class="co">-- start with an empty accumulator</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    (o1, f) <span class="op">&lt;*&gt;</span> (o2, x) <span class="ot">=</span> (o1 <span class="op">&lt;&gt;</span> o2, f x)              <span class="co">-- concat accumulators, apply the function to the value</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> o) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Writer</span> o) <span class="kw">where</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    (o1, x) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="kw">let</span> (o2, y) <span class="ot">=</span> f x <span class="kw">in</span> (o1 <span class="op">&lt;&gt;</span> o2, y) <span class="co">-- concat accumulators, carry forward the output value</span></span></code></pre></div>
<p>Here is how a chain of <code class="sourceCode pseudoml"><span class="dt">Writer</span></code> operations might look without and with monadic operations. For concreteness, I will actually use a list of <code class="sourceCode pseudoml"><span class="dt">String</span></code> values as the accumulator type:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">aValue </span><span class="op">:</span> a</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="ot">bValue </span><span class="op">:</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="ot">cValue </span><span class="op">:</span> b <span class="ot">-&gt;</span> c</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="ot">foo </span><span class="op">:</span> <span class="dt">Writer</span> [<span class="dt">String</span>] a</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>foo <span class="ot">=</span> ([<span class="st">&quot;called foo&quot;</span>], aValue)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="ot">bar </span><span class="op">:</span> a <span class="ot">-&gt;</span> <span class="dt">Writer</span> [<span class="dt">String</span>] b</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>bar a <span class="ot">=</span> ([<span class="st">&quot;called bar&quot;</span>], bValue a)</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="ot">baz </span><span class="op">:</span> b <span class="ot">-&gt;</span> <span class="dt">Writer</span> [<span class="dt">String</span>] c</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>baz b <span class="ot">=</span> ([<span class="st">&quot;called baz&quot;</span>], cValue b)</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>resultPlain <span class="ot">=</span> <span class="kw">let</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>    (o1, a) <span class="ot">=</span> foo</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>    (o2, b) <span class="ot">=</span> bar a</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    (o3, c) <span class="ot">=</span> baz b</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> (o1 <span class="op">++</span> o2 <span class="op">++</span> o3, c)</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>resultMonadic <span class="ot">=</span> foo <span class="op">&gt;&gt;=</span> bar <span class="op">&gt;&gt;=</span> baz</span></code></pre></div>
<p>In both cases, the accumulated output acts like a log indicating the order that the functions were called: <code class="sourceCode pseudoml">[<span class="st">&quot;called foo&quot;</span>, <span class="st">&quot;called bar&quot;</span>, <span class="st">&quot;called baz&quot;</span>]</code>.</p>
<h2 id="state">State<a href="#state" class="anchor" title="State">link</a></h2>
<p>Our final example of a generic monad is <code class="sourceCode pseudoml"><span class="dt">State</span></code>: the type of computations that update some kind of running “state” in addition to producing a output. This can be represented as a function from an initial state to a tuple of the final state and the output:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode pseudoml"><code class="sourceCode pseudoml"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">State</span> s a <span class="ot">=</span> s <span class="ot">-&gt;</span> (s, a)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">State</span> s) <span class="kw">where</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    map f st <span class="ot">=</span> \s <span class="ot">-&gt;</span> <span class="kw">let</span> (s, x) <span class="ot">=</span> st s <span class="kw">in</span> (s, f x)      <span class="co">-- leave the state unchanged</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">State</span> s) <span class="kw">where</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    pure x <span class="ot">=</span> \s <span class="ot">-&gt;</span> (s, x)           <span class="co">-- leave the state unchanged and just return the given value</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    stf <span class="op">&lt;*&gt;</span> stx <span class="ot">=</span> \s <span class="ot">-&gt;</span> <span class="kw">let</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>        (s1, f) <span class="ot">=</span> stf s             <span class="co">-- run the first computation to get the function and a new state</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>        (s2, x) <span class="ot">=</span> stx s1            <span class="co">-- run the second, with the updated state from the first, to get the value and another new state</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span> (s2, f x)                <span class="co">-- put them together with the final state</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">State</span> s) <span class="kw">where</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>    st <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> \s <span class="ot">-&gt;</span> <span class="kw">let</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>        (s1, x) <span class="ot">=</span> st s              <span class="co">-- run the first thing to get a new state and its value</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span> f x s1                   <span class="co">-- run the bound function with that value, then plug in the new state</span></span></code></pre></div>
<p>There isn’t much trickiness here; we just need to make sure we’re carrying the intermediate state changes forward through each step of the computation.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>If you really need to be able to map over both, there is a <code class="sourceCode pseudoml"><span class="dt">Bifunctor</span></code> typeclass that will do that for you. We will leave that for [Advanced Typeclasses][advanced-typeclasses].<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Haskell programmers may find my use of <code class="sourceCode pseudoml"><span class="kw">type</span></code> here somewhat unsettling, because in that language this would have to be defined in a <code class="sourceCode pseudoml">newtype</code> in order to allow it to get its own typeclass instances. Here, however, we are not restricted by the need to make a compiler understand our meaning, so I am doing away with all of that extra effort of unwrapping and rewrapping newtype instances, with e.g. <code class="sourceCode pseudoml">runReader</code> for the sake of human readability.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </div>
</div>
</main>
    <footer>
      <span id="site-source" class="footer-element">
        <a href="https://github.com/willj-dev/willj-dev.github.io/">Site Source</a>
      </span>
      <span class="footer-divider">|</span>
      <span id="site-source" class="footer-element">
        <a href="https://github.com/willj-dev/willj-dev.github.io/tree/main/content/pages/conceptual-fp/monad-field-guide.md">Page Source</a>
      </span>
      <span class="footer-divider">|</span>
      <div id="dark-mode" class="footer-element light-mode-only">Dark Mode</div>
      <div id="light-mode" class="footer-element dark-mode-only">Light Mode</div>
      <div class="footer-fill"></div>
      <span id="built-with" class="footer-element">
        Built with <a href="https://jaspervdj.be/hakyll">Hakyll</a>
      </span>
      <span class="footer-divider">|</span>
      <span id="hosted-by" class="footer-element">
        Hosted by <a href="https://pages.github.com">GitHub Pages</a>
      </span>
      <span class="footer-divider">|</span>
      <span id="colors-credit" class="footer-element">
        <a href="https://github.com/chriskempson/base16">Base16</a> color scheme:
        <a href="https://github.com/chriskempson/base16-tomorrow-scheme">
          Tomorrow<span class="dark-mode-only"> Night</span>
        </a>
      </span>
    </footer>
  </body>
  <script src="../js/colorMode.js"></script>
</html>
